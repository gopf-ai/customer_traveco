"""Streamlit dashboard for Traveco forecasting system

Ultra-lightweight interactive dashboard for:
- Viewing forecast metrics and trends
- Generating new forecasts
- Validating forecasts against actuals
- Configuring models
"""

import streamlit as st
import pandas as pd
import plotly.graph_objects as go
import plotly.express as px
from pathlib import Path
from datetime import datetime
import json

from src.pipeline import ForecastingPipeline
from src.utils.config import ConfigLoader


# Page configuration
st.set_page_config(
    page_title="Traveco Forecasting System",
    page_icon="üìä",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Initialize session state
if 'pipeline' not in st.session_state:
    st.session_state.pipeline = None

if 'df_forecast' not in st.session_state:
    st.session_state.df_forecast = None


def initialize_pipeline(config_path='config/config.yaml'):
    """Initialize forecasting pipeline"""
    if st.session_state.pipeline is None:
        with st.spinner("Initializing pipeline..."):
            st.session_state.pipeline = ForecastingPipeline(config_path=config_path)
    return st.session_state.pipeline


def page_dashboard():
    """Main dashboard page"""
    st.title("üìä Traveco Forecasting Dashboard")

    st.markdown("""
    Welcome to the Traveco Transport Logistics Forecasting System.

    This dashboard provides ML-based forecasting for key operational metrics:
    - **Revenue** (transportation + total)
    - **Personnel Costs**
    - **External Drivers**
    """)

    # Initialize pipeline
    pipeline = initialize_pipeline()

    # File uploader for forecast data
    st.subheader("üìÅ Load Forecast Data")

    col1, col2 = st.columns(2)

    with col1:
        forecast_file = st.file_uploader(
            "Upload forecast CSV",
            type=['csv'],
            help="Upload a forecast file generated by the system"
        )

    with col2:
        # Or select from existing forecasts
        forecasts_dir = Path(pipeline.config.get('paths.forecasts_dir', 'forecasts'))

        if forecasts_dir.exists():
            forecast_files = list(forecasts_dir.glob('*.csv'))
            if forecast_files:
                selected_file = st.selectbox(
                    "Or select existing forecast",
                    options=[''] + [f.name for f in forecast_files]
                )

                if selected_file:
                    forecast_file = forecasts_dir / selected_file

    # Load and display forecast
    if forecast_file:
        if isinstance(forecast_file, str) or isinstance(forecast_file, Path):
            df_forecast = pd.read_csv(forecast_file)
        else:
            df_forecast = pd.read_csv(forecast_file)

        st.session_state.df_forecast = df_forecast

        # Convert date column
        df_forecast['date'] = pd.to_datetime(df_forecast['date'])

        # Display summary metrics
        st.subheader("üìà Forecast Summary")

        # Get core metrics
        core_metrics = pipeline.config.get('features.core_metrics', [
            'revenue_total',
            'personnel_costs',
            'external_drivers'
        ])

        # Add total revenue if available
        if 'total_revenue_all' in df_forecast.columns:
            core_metrics = ['total_revenue_all'] + core_metrics

        # Display metrics in columns
        cols = st.columns(len(core_metrics))

        for idx, metric in enumerate(core_metrics):
            if metric in df_forecast.columns:
                with cols[idx]:
                    total = df_forecast[metric].sum()
                    avg = df_forecast[metric].mean()

                    # Format metric name
                    metric_name = metric.replace('_', ' ').title()

                    st.metric(
                        label=metric_name,
                        value=f"CHF {total:,.0f}" if 'revenue' in metric or 'cost' in metric else f"{total:,.0f}",
                        delta=f"Avg: CHF {avg:,.0f}" if 'revenue' in metric or 'cost' in metric else f"Avg: {avg:,.0f}"
                    )

        # Interactive charts
        st.subheader("üìâ Forecast Trends")

        # Metric selector
        selected_metric = st.selectbox(
            "Select metric to visualize",
            options=[m for m in core_metrics if m in df_forecast.columns],
            format_func=lambda x: x.replace('_', ' ').title()
        )

        if selected_metric:
            # Line chart
            fig = go.Figure()

            fig.add_trace(go.Scatter(
                x=df_forecast['date'],
                y=df_forecast[selected_metric],
                mode='lines+markers',
                name=selected_metric.replace('_', ' ').title(),
                line=dict(color='#1f77b4', width=3),
                marker=dict(size=8)
            ))

            fig.update_layout(
                title=f"{selected_metric.replace('_', ' ').title()} - Monthly Forecast",
                xaxis_title="Date",
                yaxis_title="Value",
                hovermode='x unified',
                height=500
            )

            st.plotly_chart(fig, use_container_width=True)

        # Revenue ratio insights (if available)
        if all(col in df_forecast.columns for col in ['revenue_ratio', 'revenue_ratio_simple', 'revenue_ratio_ml']):
            st.subheader("üí∞ Revenue Ratio Insights")

            col1, col2 = st.columns(2)

            with col1:
                # Ratio comparison
                fig = go.Figure()

                fig.add_trace(go.Scatter(
                    x=df_forecast['date'],
                    y=df_forecast['revenue_ratio_simple'],
                    mode='lines',
                    name='Simple Model',
                    line=dict(dash='dash')
                ))

                fig.add_trace(go.Scatter(
                    x=df_forecast['date'],
                    y=df_forecast['revenue_ratio_ml'],
                    mode='lines',
                    name='ML Model',
                    line=dict(dash='dot')
                ))

                fig.add_trace(go.Scatter(
                    x=df_forecast['date'],
                    y=df_forecast['revenue_ratio'],
                    mode='lines+markers',
                    name='Ensemble',
                    line=dict(width=3)
                ))

                fig.update_layout(
                    title="Revenue Ratio Models Comparison",
                    xaxis_title="Date",
                    yaxis_title="Ratio (Total/Transportation)",
                    hovermode='x unified',
                    height=400
                )

                st.plotly_chart(fig, use_container_width=True)

            with col2:
                # Ratio statistics
                st.metric(
                    "Average Revenue Ratio",
                    f"{df_forecast['revenue_ratio'].mean():.3f}",
                    delta=f"Range: {df_forecast['revenue_ratio'].min():.3f} - {df_forecast['revenue_ratio'].max():.3f}"
                )

                # Load ensemble weights if available
                try:
                    pipeline.load_models()
                    if pipeline.revenue_ensemble:
                        weights = pipeline.revenue_ensemble.get_weights()

                        st.write("**Ensemble Weights:**")
                        st.progress(weights['ml_model'], text=f"ML Model: {weights['ml_model']:.0%}")
                        st.progress(weights['percentage_model'], text=f"Simple Model: {weights['percentage_model']:.0%}")
                except:
                    pass

        # Data table
        st.subheader("üìã Forecast Data")

        st.dataframe(
            df_forecast.style.format({
                col: "{:,.0f}" for col in df_forecast.columns
                if col not in ['date', 'model_type', 'forecast_date'] and pd.api.types.is_numeric_dtype(df_forecast[col])
            }),
            use_container_width=True,
            height=400
        )

    else:
        st.info("üëÜ Upload or select a forecast file to view the dashboard")


def page_generate_forecast():
    """Forecast generation page"""
    st.title("üîÆ Generate Forecast")

    # Initialize pipeline
    pipeline = initialize_pipeline()

    st.markdown("""
    Generate new forecasts for specified periods using trained models.
    """)

    # Form for forecast parameters
    with st.form("forecast_form"):
        st.subheader("Forecast Parameters")

        col1, col2 = st.columns(2)

        with col1:
            year = st.number_input(
                "Forecast Year",
                min_value=2020,
                max_value=2030,
                value=2025,
                step=1
            )

            months = st.slider(
                "Number of Months",
                min_value=1,
                max_value=24,
                value=12,
                step=1
            )

        with col2:
            model_type = st.selectbox(
                "Model Type",
                options=['xgboost', 'seasonal_naive', 'moving_average', 'linear_trend'],
                index=0
            )

            include_revenue = st.checkbox(
                "Include Total Revenue Forecast",
                value=True,
                help="Generate total revenue forecast using ensemble model"
            )

        submitted = st.form_submit_button("Generate Forecast", type="primary")

    if submitted:
        with st.spinner(f"Generating {months}-month forecast for {year}..."):
            try:
                # Load historical data
                pipeline.load_data()

                # Load models
                pipeline.load_models()

                # Generate forecast
                df_forecast = pipeline.generate_forecast(
                    year=year,
                    n_months=months,
                    model_type=model_type,
                    include_revenue_forecast=include_revenue,
                    save_forecast=True
                )

                st.session_state.df_forecast = df_forecast

                st.success(f"‚úÖ Forecast generated successfully!")

                # Display summary
                st.subheader("Forecast Summary")

                cols = st.columns(4)

                metrics = [
                    ('revenue_total', 'Transportation Revenue'),
                    ('personnel_costs', 'Personnel Costs'),
                    ('external_drivers', 'External Drivers'),
                    ('total_revenue_all', 'Total Revenue')
                ]

                for idx, (metric, label) in enumerate(metrics):
                    if metric in df_forecast.columns:
                        with cols[idx % 4]:
                            total = df_forecast[metric].sum()
                            st.metric(label, f"CHF {total:,.0f}" if 'revenue' in metric or 'cost' in metric else f"{total:,.0f}")

                # Download button
                csv = df_forecast.to_csv(index=False)
                st.download_button(
                    label="üì• Download Forecast CSV",
                    data=csv,
                    file_name=f"forecast_{year}_{model_type}_{datetime.now().strftime('%Y%m%d')}.csv",
                    mime='text/csv'
                )

            except Exception as e:
                st.error(f"‚ùå Error generating forecast: {str(e)}")


def page_validation():
    """Forecast validation page"""
    st.title("‚úÖ Validate Forecast")

    # Initialize pipeline
    pipeline = initialize_pipeline()

    st.markdown("""
    Validate forecasts against actual data to measure prediction accuracy.
    """)

    col1, col2 = st.columns(2)

    with col1:
        st.subheader("Forecast Data")
        forecast_file = st.file_uploader(
            "Upload forecast CSV",
            type=['csv'],
            key='validation_forecast'
        )

    with col2:
        st.subheader("Actual Data")
        actual_file = st.file_uploader(
            "Upload actual data CSV",
            type=['csv'],
            key='validation_actual'
        )

    if forecast_file and actual_file:
        # Load data
        df_forecast = pd.read_csv(forecast_file)
        df_actual = pd.read_csv(actual_file)

        st.success(f"‚úÖ Loaded {len(df_forecast)} forecast periods and {len(df_actual)} actual periods")

        # Select metrics to validate
        core_metrics = pipeline.config.get('features.core_metrics', [
            'revenue_total',
            'personnel_costs',
            'external_drivers'
        ])

        if 'total_revenue_all' in df_forecast.columns and 'total_revenue_all' in df_actual.columns:
            core_metrics.append('total_revenue_all')

        selected_metrics = st.multiselect(
            "Select metrics to validate",
            options=[m for m in core_metrics if m in df_forecast.columns and m in df_actual.columns],
            default=[m for m in core_metrics if m in df_forecast.columns and m in df_actual.columns]
        )

        if st.button("Run Validation", type="primary"):
            with st.spinner("Calculating validation metrics..."):
                try:
                    # Validate
                    validation_results = pipeline.validate_forecast(
                        df_forecast=df_forecast,
                        df_actual=df_actual,
                        metrics_to_validate=selected_metrics
                    )

                    st.success("‚úÖ Validation complete!")

                    # Display results
                    st.subheader("Validation Results")

                    # Create results table
                    results_data = []
                    for metric, results in validation_results.items():
                        results_data.append({
                            'Metric': metric.replace('_', ' ').title(),
                            'MAPE (%)': f"{results['mape']:.2f}",
                            'MAE': f"{results['mae']:,.0f}",
                            'RMSE': f"{results['rmse']:,.0f}",
                            'R¬≤': f"{results['r2']:.3f}"
                        })

                    df_results = pd.DataFrame(results_data)
                    st.dataframe(df_results, use_container_width=True)

                    # Visualize MAPE
                    st.subheader("MAPE Comparison")

                    fig = go.Figure(data=[
                        go.Bar(
                            x=[r['Metric'] for r in results_data],
                            y=[float(r['MAPE (%)']) for r in results_data],
                            text=[r['MAPE (%)'] + '%' for r in results_data],
                            textposition='auto',
                        )
                    ])

                    fig.update_layout(
                        title="Mean Absolute Percentage Error by Metric",
                        xaxis_title="Metric",
                        yaxis_title="MAPE (%)",
                        showlegend=False,
                        height=400
                    )

                    st.plotly_chart(fig, use_container_width=True)

                    # Download results
                    results_json = json.dumps(validation_results, indent=2)
                    st.download_button(
                        label="üì• Download Validation Results",
                        data=results_json,
                        file_name=f"validation_results_{datetime.now().strftime('%Y%m%d')}.json",
                        mime='application/json'
                    )

                except Exception as e:
                    st.error(f"‚ùå Error during validation: {str(e)}")

    else:
        st.info("üëÜ Upload both forecast and actual data files to begin validation")


def page_settings():
    """Settings and configuration page"""
    st.title("‚öôÔ∏è Settings")

    # Initialize pipeline
    pipeline = initialize_pipeline()

    st.markdown("""
    Configure the forecasting system and manage models.
    """)

    # Model status
    st.subheader("üì¶ Model Status")

    models_dir = Path(pipeline.config.get('paths.models_dir', 'models'))

    if models_dir.exists():
        model_files = list(models_dir.glob('*.pkl'))

        if model_files:
            st.success(f"‚úÖ Found {len(model_files)} trained models")

            # Display model details
            model_data = []
            for model_file in model_files:
                size = model_file.stat().st_size / 1024  # KB
                modified = datetime.fromtimestamp(model_file.stat().st_mtime)

                model_data.append({
                    'Model': model_file.name,
                    'Size (KB)': f"{size:.1f}",
                    'Last Modified': modified.strftime('%Y-%m-%d %H:%M')
                })

            df_models = pd.DataFrame(model_data)
            st.dataframe(df_models, use_container_width=True)

        else:
            st.warning("‚ö†Ô∏è No trained models found")
            st.info("Train models using the CLI: `python traveco-forecast train`")
    else:
        st.warning("‚ö†Ô∏è Models directory not found")

    # Configuration
    st.subheader("‚öôÔ∏è Configuration")

    config_data = {
        'Core Metrics': ', '.join(pipeline.config.get('features.core_metrics', [])),
        'Data Directory': pipeline.config.get('paths.raw_data_dir', 'data/raw'),
        'Models Directory': str(models_dir),
        'Forecasts Directory': pipeline.config.get('paths.forecasts_dir', 'forecasts')
    }

    for key, value in config_data.items():
        st.text(f"{key}: {value}")

    # Model training
    st.subheader("üîß Model Management")

    st.markdown("""
    To train models, use the command-line interface:

    ```bash
    # Train all models
    python traveco-forecast train

    # Train with custom date range
    python traveco-forecast train --start-date 2022-01-01 --end-date 2024-12-31

    # Skip certain model types
    python traveco-forecast train --skip-baseline
    ```
    """)


# Sidebar navigation
st.sidebar.title("üöö Traveco Forecasting")
st.sidebar.markdown("---")

page = st.sidebar.radio(
    "Navigation",
    options=[
        "üìä Dashboard",
        "üîÆ Generate Forecast",
        "‚úÖ Validate Forecast",
        "‚öôÔ∏è Settings"
    ]
)

st.sidebar.markdown("---")
st.sidebar.markdown("""
**System Info**

Version: 1.0.0
ML Models: XGBoost, Prophet, SARIMAX
Revenue Modeling: Ensemble Approach
""")

# Route to selected page
if page == "üìä Dashboard":
    page_dashboard()
elif page == "üîÆ Generate Forecast":
    page_generate_forecast()
elif page == "‚úÖ Validate Forecast":
    page_validation()
elif page == "‚öôÔ∏è Settings":
    page_settings()
